Reboot and Shutdown

* systemctl stands for "system control".

commands:
$ systemctl reboot: reboot the system, use --force if system refuse to reboot because of non responding program or another reason that is preventing the normal reboot, use this only as a last resort since it won't give the running programs to close properly or save their data. Also you can use double --force e.g. --force --force which will act as a reset button click.

$ systemctl poweroff: shutdown the system, --force can be used here as well, use this only as a last resort. Using double force here will work as unplugging the computer from its power source.

$ shutdown <scheduled time e.g. 02:00>: schedule a time that the system will shutdown at. And, to reboot add the -r flag. A wall message can be passed to the users so they know when the system is going to shutdown or reboot and why, to do that, pass a single quote argument at the end of the commands, e.g. sudo shutdown -r +1 'Scheduled a reset after 1 minute'

_______________________________________

Boot or Change the system to different operating modes

* Some targets information:
1- emergency.target: load up as few programs as possible, this target could be useful for debugging when other targets are loading programs that is making your system unstable. The root file system will be mounted as read only in this target.

2- rescue.target: load few more programs than emergency.target, this target is useful to backup data basis and fix system settings and so on, in this target you will be dropped into a root shell where you can type commands. Note, you need to have a password set to root user to get into these two targets running since you are going to login as root user.

commands:
$ systemctl isolate <boot target e.g graphical.target>: switch to a operating target without the need to reboot after using $ systemctl set-default command.

_______________________________________

Install, Configure, and Troubleshoot the Linux Bootloaders

* Bootloader is one of the first programs that starts in a linux system, one purpose of it, is to start the linux kernel. GRUB (Grand Modified Bootloader), is the most popular linux bootloader.

* BIOS (basic input/output system) is the program a computer's microprocessor uses to start the computer system after it is powered on. In other words, the console you get when you install linux. When a computer boots through a BIOS, the computer looks for the bootloader at the very begging of the disk, that means we need to place GRUB bootloader in the first few sectors of that disk.

* First thing when we are in troubleshoot mode via a boot stick, is to know which disk we should install GRUB into, using the $lsblk command. In $lsblk, block devices starting with sd are physical and devices starting with vd are virtual. Computers that use efi does not look for bootloaders on the first sector of the disk, rather they look for it in a file stored in a boot partition.

* To make changes or settings of grub, you can edit the configuration file /etc/default/grub. For example you can edit the GRUB_TIMEOUT, to control how much time GRUB console menu should show up before computer starts.  Once edited we have to regenerate GRUB configuration file using $ grub2-mkconfig -o /boot/grub2/grub.cfg, or for efi mode $grub2-mkconf ig -o /boot/efi/EFI/centos/grub.cfg.

commands:
$ chroot <another file system root e.g /mnt/sysroot>: run command or interactive shell with special root directory.
$ sudo grub2-install /dev/vda > /home/bob/grub.txt 2>&1: install grub bootloader to /dev/vda disk.


_______________________________________

Using Scripting to Automate System Maintenance Tasks


* Adding sh to the end of script file is not mandatory, though it is best practice, sometimes we need to not add sh when we want another program to run that script such as cron.



commands:
$ help: get bash built-ins directives. Or, use $ help <directive>, e.g $ help if, to get how to use that directive.
$ test: bash built-in to evaluate expressions and can be used in if statement, it can run file conditions. To see how to use it, run $ man test, or help test.


_______________________________________

Manage the Startup Process and Services

* init system has the instructions of what services to start, when to start them and what service it depends on, are all defined in "Units", Units are text files the describes the logic. There are four types of Units:
1- Service
2- Socket
3- Device
4- Timer

* If a service is "enabled" that means that the service will automatically starts up when the system boots, and "disabled" means that the service can be manually started by the administrator.

* When running the $ systemctl status <service name> command, if the status is "active (running)" that mean the program is launched and loaded into memory and it is active and running. When a service is running it will have a Process Identifier (PID), since every time we start a service or launch a program a process (computer code loaded into memory, and using the cpu when it needs to execute instructions) will start up. Also, we can see the exact command that has been used to start up the process. And finally, system status command will show us few log lines generated by this application , these lines can be useful to see what happened after this program started up.

commands:
$ man systemd.service: see the options that you can add to a service unit.
$ systemctl cat <service name e.g. sshd.service>: print the unit file for a service.
$ systemctl revert <service name e.g. sshd.service>: revert a service (uint files) to its factory configuration.
$ systemctl status <service name e.g. sshd.service>: print a service status.
$ systemctl stop <service name e.g. sshd.service>: stop a service the specified service unit controls.
$ systemctl start <service name e.g. sshd.service>: start a service the specified service unit controls.
$ systemctl restart <service name e.g. sshd.service>: restart a service the specified service unit controls, though this command could be disruptive if certain users are using the service. use $reload command instead.
$ systemctl reload <service name e.g. sshd.service>: reload a service the specified service unit controls. This command will reload the service setting instead of restarting it.
$ systemctl reload-or-restart <service name e.g. sshd.service>: not all services can be reloaded, thus use this command where systemctl will try to reload first then restart if the reload fails.
$ systemctl disable <service name e.g. sshd.service>: disable a service the the specified service unit controls to start at boot. Use --now flag to start the service as well.
$ systemctl enable <service name e.g. sshd.service>: enable a service the the specified service unit controls to start at boot. Use --now flag to start the service as well.
$ systemctl is-enable <service name e.g. sshd.service>: check if a service is enabled.
$ systemctl mask <service name e.g. sshd.service>: prevent other services from starting up certain service as well as disabling the service and not allowing it to start even manually.
$ systemctl unmask <service name e.g. sshd.service>: unmask a service.
$ systemctl list-units --type service --all: list all units of type service.

_______________________________________

Create Systemd Services

* For service units examples, go to /lib/systemd/system/.

* Your services should be places at /etc/systemd/system/<myapp.service>.

* A daemon is also called background processes, e.g. sshd stands for "ssh daemon"

commands:
$ systemd-cat: connect a pipeline or a program with journal, in other words write logs to journalctl logs.
$ man systemd.service: show man page for unit files. look for EXAMPLES. type $ man systemd. , and double tap to see the other options apart from service.
$ sudo systemctl daemon-reload: reload systemd daemon, which is required whenever a service unit is added, removed, or edited.
$ journalctl -f: print system logs, -f flag runs the command with follow mode (watch).


_______________________________________

Diagnosis and Manage processes


* It's possible to inspect processes using the $ps command, this command has two flag syntaxes, if run with dashes as -a this is the unix style syntax, and without dashes is BSD style syntax and each has different effects. With "aux" flag we will get process information such which user the process was ran under and the PID, CPU, and other information.

* Some processes might be on sleep, state that is why they appear in the $ps command result but with current zero CPU usage. The MEM column represent how how much CPU time was used by the process, 1 means the process used 100% of one cpu core for one second, and other calculations are made accordingly.

* Processes with command rapped in brackets belongs to the kernel, they are not running in user space, so usually we would not interact with them.

* In linux there is a concept that describes the process priority, the concept is called product niceness. It's how nice a process is to other processes, higher number means the process is nicer to other processes. the niceness can be a number from -20 to +19. Furthermore, a lower number means the process has higher priority. Use the $nice command in the launching of a process. a process with number of -20 will leave the spare CPU for a process with a nice number of +19. Note that to assign a lower nice value for higher priority, we have to use root privilege, since only root user can set the NI of a process to negative value.

* Signals tells programs to do something that they are programmed to do, the only signals that can be used without the processes been programmed to respond to, is the stop and kill signals.

* Processes can run on the background (not visible in the terminal) and on the foreground (visible on terminal). For example, pressing "ctrl + z" in vim stops and pushes vim to the background and typing the command $fg start it and bring it back to the foreground.

* It's possible to background a command when typing it by using the and percent symbol (&) after it, e.g. $ sleep 10 &. When using this, it will give us a job number that we can use to get the process back to the foreground using the $ fg <job number> command.


commands:
$ ps: report a snapshot of the current processes. By default ps is going to show us the processes running in our current window or session. Some ps flags explained below. $ ps aux (auxiliary), is the most used command to view all processes in linux. Search for EXAMPLES in the man pages to see some flag combinations and their usage in both UNIX and BSD style syntaxes. The "u" flag is for user oriented format.
$ top: display Linux processes, show us processes in watch mode. Top will show the most CPU intensive processes at the top. Also it gives general information at the top.
$ ps <PID>: get information for a specific process.
$ ps u <PID>: get information for a specific process with user oriented flag.
$ ps -U <username>: print all processes that belongs to certain user.
$ pgrep -a <process name e.g. syslog>: search process by name.
$ nice -n <niceness number e.g. 11> <process e.g. bash: run a program with modified scheduling priority.
$ ps -l: print processes with more information, including the nice value (Look at the NI column). Use $ ps lax to see all the processes and their nice numbers, not only by the current user.
$ ps fax: shows the tree relationship between processes (which process was started by another), think of f as forest.
$ renice <nice value> <PID>: alter priority of running processes, change the nice value of a running process.
$ kill -L: kill sends a signal to a process or service's process, using the -L flags list all the signals that can be sent to a process.
$ kill <signal name or number e.g. -SIGKILL or -KILL or -9>: send signal to a process via PID.
$ kill <PID>: tells a program to gracefully shut down by give it time to save its work and close down normally.
$ pkill <signal> <process name>: send signals to processes using their names rather their PIDs.
$ fg <job number>: foreground a program (bring it to the terminal), if typed without a job number it will foreground job number 1.
$ jobs: see the current jobs.
$ bg: run the process that was stopped in the background, as for example if we stopped and background the sleep command using "ctrl + z".
$ lsof -p <PID>: list open files that are opened by certain process.
$ lsof <file or directory path>: list processes that are using this file or directory, the opposite of the previous command.

_______________________________________

Locate and Analyze System Log Files

* Linux Systems are largely server oriented, and every thing that happens in a Linux system are saved as text somewhere, which is called logs.

* Most popular logging daemon is rsyslog (rocket-fast system for log processing), rsyslog stores logs in /var/log/ directory and can be searched using $grep command or any text utility. You might want to login as root user since most of these files can not be read by regular users.

* Most logs are written in the following order: Date User-Host Source(application) Log-Message.

* Some log files have numbers on them, these numbers represent the date of the logs, are they old or recent logs. Older logs will be renamed.

* journalctl is a smart tool to search logs.

* There are four types of logs:
1- info
2- warning
3- err
4- crit (critically wrong)
type journalctl -p (--priority flag) then double tab to see journalctl log types that you can search for independently.

commands:
$ tail -F <log file e.g. /var/log/source>: see logs in follow mode (watch).
$ journalctl <command path e.g. /bin/sudo>: see the logs generated by certain command, in this case we are checking logs generated by the $sudo command, the path can be obtained using $which command. Note, this command show the logs in the less utility, use ">" to go to the end of the logs, or use the -e flag with the command.
$ journalctl -u <service name>: display logs generated by a service unit.
$ journalctl -f: access journalctl log in follow mode. Use -g to search with regular expression.
$ journalctl -S <24h format or date> -U <24hour format or date>: search with starting date and until date.
$ journalctl -b 0: see logs from current boot, use -1 to see logs from previous boot and so on.
$ last: show a list of last logged in users. The line with system boot shows when the system was powered on.
$ lastlog: shows when each user on the system logged in last time, and if they logged in through ssh, you can see the ip address from which they logged in.


_______________________________________

Schedule Tasks to Run at a Set Time

* There are three ways to schedule tasks in linux:
1- cron (at /etc/crontab)
2- anacron (at /etc/anacrontab)
3- at

* anacron utility is similar to cron utility, but the smallest frequency it can be scheduled to run at is days (we don't care at which time of the day it runs at) unlike cron where you can use minutes. Another difference is that anacron utility if the computer was powered on after the scheduled time of a task it will still execute it once the computer is powered on, unlike cron where the task will be missed.

* The $at command run a command only once at a specified time.

* Look at /etc/crontab file to  get a syntax reminder of how to add a cron by looking at the  default system-wide cron table. Note that jobs should not be added directly to the system-wide cron table, rather they should be added to user personal cron table.

* In the time columns, asterisk (*) means match every field, comma (,) with no spaces can be used to specify multiple values for certain columns, dash (-) can be used to specify range, and slash (/) can be used as a step. Also, multiple symbols can be combined e.g 0-8/4 in the hours column means run at 0am, 4am, and 8am.

* In crontab, use the full path of the command.

* Edit user crontab with $crontab -e command.

* Shell scripts should have no extensions if we want to run them as cron jobs.

* Another way of setting cron tasks is to add scripts to the frequency specific directory, e.g. $ sudo cp shellscript /etc/cron.hourly/ and give it the correct permissions (+rx). There are four directories for that purpose:
1- /etc/cron.hourly/
2- /etc/cron.daily/
3- /etc/cron.weekly/
4 - /etc/cron.monthly/

* anacron example:
3   10 <job name> <command (use full path of a command)>
This means job run every three days, and add a delay of ten minutes when job are been missed so that if there are more than one job, they don't all run at the same time. And, the job name is useful for logging.

* Add @weekly and @monthly in the days column to run the command weekly or monthly.



commands:
$ crontab -l: list the crontab jobs of current user. Add sudo in front to edit the crontab of root user.
$ sudo crontab -e -u <another user>: run a cron tab command e.g. edit, list, and so on, as another user. or just log in as that user.
$ crontab -r: remove user crontab.
$ anacron -T: verify the syntax of the anacron job using the Test flag (-T).
$ at <Time or date, e.g. 15:00 or 'August 20 2024' or '2:30 August 20 2024'>: add a cron job using the at command, after entering the command a prompt will be open to add commands at and it can be saved and exited using "ctrl+d".
$ sudo anacron -n: run all anacron jobs now (-n), works only for jobs that have not ran today.
$ sudo anacron -n -f: force all anacron jobs to run now, regardless weather of the last time they been executed.
$ at <relative time e.g. 'now + 3 hours' or 'now + 3 minutes'>: set jobs using relative time, so for the first example run the job after 3 hours. Same can be done with weeks, days, or months.
$ atq: list what jobs are scheduled to run with the $at utility, along their job ids.
$ at -c <job id>: display what an $at job contains (-c), get the job id from the $atq command.
$ atrm <job id>: remove $at job using the job id.

_______________________________________

Verify Completion of Scheduled Jobs

* depending on the machine and distribution cron logs can be found in different files /var/log/cron or in my case /var/log/syslog. 

* In /etc/crontab and /etc/anacrontab there are MAILTO field that can be set to send logs, to some user mail or a set mail

* The $at utility daemon is atd, so that's what you want to look for when searching $at job logs.

command:
